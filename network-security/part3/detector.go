/*
 * Stanford CS155 Project 3
 * Part 3. Anomaly Detection
 *
 * detector.go
 *
 * When completed (by you!) and compiled, this program will:
 *
 *  - Open a .pcap file supplied as a command-line argument, and analyze the TCP,
 *    IP, Ethernet, and ARP layers
 *
 *  - Print the IP addresses that: 1) sent more than 3 times as many SYN packets
 *    as the number of SYN+ACK packets they received, and 2) sent more than 5 SYN
 *    packets in total
 *
 *  - Print the MAC addresses that send more than 5 unsolicited ARP replies
 *
 * This starter code is provided solely for convenience, to help build
 * familiarity with Go. You are free to use as much or as little of this code
 * as you see fit.
 */

package main

import (
	// You may use any packages in gopacket or the Go standard library,
	// but we think these should be sufficient. You MAY NOT use any
	// third party libraries. The autograder will not build with these.

	"fmt"
	"os"
	"net" // added to cast byte arrays to IP/MAC addresses

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/google/gopacket/pcap"
)

/*
	TODO: obtain the source and destination IP addresses using
	ipLayer, and the TCP flags using tcpLayer. Update the variable
	addresses accordingly. You will want to have an if-statement
	that branches on SYN vs. SYN/ACK. Note than a SYN packet has
	the SYN flag set to true, AND the ACK flag set to false!
*/
func parseIpTcp(addresses *map[string][2]int, ipLayer gopacket.Layer, tcpLayer gopacket.Layer) {	
	// Get IP packet...
	ipPacket, _ := ipLayer.(*layers.IPv4)

	// ... and TCP packet...
	tcpPacket, _:= tcpLayer.(*layers.TCP)

	// ... then update sent-syn count
	if tcpPacket.SYN && !tcpPacket.ACK {
		srcIpString := net.IP(ipPacket.SrcIP).String()
		counts := (*addresses)[srcIpString]
		counts[0]++
		(*addresses)[srcIpString] = counts
	}  else if tcpPacket.SYN && tcpPacket.ACK {
		//  ...and update received-synack count
		dstIpString := net.IP(ipPacket.DstIP).String()

		counts := (*addresses)[dstIpString]
		counts[1]++
		(*addresses)[dstIpString] = counts
	}
}

/*
arpRequests should map from IP we're looking for (key) to another map
that maps from sender MAC address and the counts 
*/


/*
	TODO: Use the arp variable to get (IP address, MAC address)
	pairs for the source and destination. Fill in the if-else if
	statement below as well. arp.Operation has a value of 1 if the
	ARP packet is a request, and 2 if it is a reply. Update the
	variable arpRequests accordingly. If you spot an unsolicited
	reply, update arpMac.
*/
func parseArp(arpRequests *map[string]map[string]int, arpMac *map[string]int, arpLayer gopacket.Layer) {	
	arp, _ := arpLayer.(*layers.ARP)

	// Parse arp to get additional info
	if arp.Operation == 1 { // ARP request
		// IP address that ARP is looking for
		arpReqIp := net.IP(arp.DstProtAddress).String()

		arpReqSrcMac := net.HardwareAddr(arp.SourceHwAddress).String()

		// add new entry to arpRequests map if first arpRequest for this IP address
		_, exists := (*arpRequests)[arpReqIp]
		if !exists {
			(*arpRequests)[arpReqIp] = make(map[string]int)
			(*arpRequests)[arpReqIp][arpReqSrcMac] = 1
		} else { // if val, ok := arpReqEntry[arpReqSrcMac]; ok
			// increment num requests for IP from this MAC address
			currVal := (*arpRequests)[arpReqIp][arpReqSrcMac]
			currVal++
			(*arpRequests)[arpReqIp][arpReqSrcMac] = currVal
		}

	} else if arp.Operation == 2 { // ARP reply
		ArpSrcMac := net.HardwareAddr(arp.DstHwAddress).String()

		IPRequested := net.IP(arp.SourceProtAddress).String()

		// if arpRequest exists in requests
		value, exists := (*arpRequests)[IPRequested]
		if exists && (*arpRequests)[IPRequested][ArpSrcMac] > 0 { 
			// decrement num open reqs for tuple corresponding to 
			// (IP addr it's looking for & MAC that sent it)
			currNumOpenReqs := value[ArpSrcMac]
			currNumOpenReqs--
			(*arpRequests)[IPRequested][ArpSrcMac] = currNumOpenReqs
		} else { // unsollicited reply
			// increment num offenses by given MAC address
			srcMacAddress := net.HardwareAddr(arp.SourceHwAddress).String()
			currNumOffenses := (*arpMac)[srcMacAddress]
			currNumOffenses++
			(*arpMac)[srcMacAddress] = currNumOffenses
		}
	}
}


func main() {
	if len(os.Args) != 2 {
		panic("Invalid command-line arguments")
	}
	pcapFile := os.Args[1]

	// Attempt to open file
	if handle, err := pcap.OpenOffline(pcapFile); err != nil {
		panic(err)
	} else {
		packetSource := gopacket.NewPacketSource(handle, handle.LinkType())

		// map {key = IP address, value = array of 2 ints representing [syn, synack] counts}
		// syn = count of number sent; synack = count of number received
		addresses := map[string][2]int{}

		// map {key = IP address, value = map {key = originator MAC address, value = int}. 
		// Used to track num requests for certain IP, coming from certain MAC
		// used to detect spoofers: if their reply isn't matched by
		// a request from here, it's unsolicited
		arpRequests := map[string]map[string]int{}

		// list of spoofers
		arpMac := map[string]int{}

		// Loop through packets in file
		for packet := range packetSource.Packets() {
			tcpLayer := packet.Layer(layers.LayerTypeTCP)
			ipLayer := packet.Layer(layers.LayerTypeIPv4)
			etherLayer := packet.Layer(layers.LayerTypeEthernet)
			arpLayer := packet.Layer(layers.LayerTypeARP)
		
			if tcpLayer != nil && ipLayer != nil && etherLayer != nil {
				parseIpTcp(&addresses, ipLayer, tcpLayer)
			} else if arpLayer != nil {
				parseArp(&arpRequests, &arpMac, arpLayer)
			}
		}

		fmt.Println("Unauthorized SYN scanners:")
		for ip, addr := range addresses {
			num_syn_sent := addr[0]
			num_synack_received := addr[1]

			// fmt.Printf("Num syn sent: %d, num synack received: %d", num_syn_sent, num_synack_received)

			if (float64(num_syn_sent) / float64(num_synack_received)) > 3 && num_syn_sent > 5 {
				fmt.Printf("%s \n", ip)
			}
		}

		fmt.Println("Unauthorized ARP spoofers:")
		for mac, count := range arpMac {
			// fmt.Printf("MAC address: %s has %d unsollicited ARP responses", mac, count)
			if count > 5 {
				fmt.Printf("%s \n", mac)
			}
		}
	}
}

/*
// We provide some data structures that you may find useful.
// Maps in Go are very similar to Python's dictionaries.
// The Go syntax to declare an empty map is map[KEY_TYPE]VALUE_TYPE{}.


Hints and Links to Documentation:

To access the member variables of each Layer,
you will need to type-cast it to the correct struct. For example,
tcpData, _ := tcpLayer.(*layers.TCP)

Here are some links to useful pages of Gopacket documentation, or
source code of layer objects in Gopacket. The names of the
struct member variables are self-explanatory.

https://github.com/google/gopacket/blob/master/layers/tcp.go Lines 20-35
https://github.com/google/gopacket/blob/master/layers/ip4.go Lines 43-59
https://github.com/google/gopacket/blob/master/layers/arp.go Lines 18-36
In arp.go, HwAddress is the MAC address, and
ProtAddress is the IP address in this case. Both are []byte variables.

https://golang.org/pkg/net/#IP and HardwareAddr (scroll up!) are
new type definitions for a []byte. Read more about type definitions at:
https://stackoverflow.com/questions/49402138/what-is-the-meaning-of-this-type-declaration
Hint: you can type-cast a []byte to a net.IP or net.HardwareAddr object.

https://golang.org/pkg/net/#IP.String - How to stringify IP addresses
https://golang.org/pkg/net/#HardwareAddr.String - How to stringify MAC addresses
*/
