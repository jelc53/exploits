\documentclass[twoside,11pt]{article}
\setlength{\parindent}{0pt}

\usepackage{cs155}
\usepackage{lipsum}
\usepackage{listings}

\input{julia_listing}


\begin{document}

% Refer to this link for project rubric: https://web.stanford.edu/class/aa228/cgi-bin/wp/project-1/
\title{Project 1: Control Hijacking}

%===========================================
% TODO: Replace "First Last" with your name.
% TODO: Replace "email@stanford.edu" with your Stanford email.
%===========================================
\name{Julian Cooper}
\email{jelc@stanford.edu}


\maketitle


\section{Buffer Overflow \#1}
%===========================================
% TODO: Replace this with a short description of your algorithm(s) used.
Vulnerability: Want to exploit \texttt{strcpy} being called without bounds checking. \\

Exploit: We can overwrite the return address of \texttt{foo} with the address of our shellcode, then execute the shellcode to get a root shell.\\

Working notes:
\begin{itemize}
    \item Using gdb we can find address of the buffer variable, 0x7fffffffdc20.
    \item We then can find the address of the return address, 0x7fffffffdd28.
    \item The difference of these two addresses is 0x108 (264), which is the number of bytes we need to overwrite to get to the return address.
    Note, we need to add 8 bytes to this to account for the saved return address, so our exploit must be 272 bytes long.
    \item Copy shellcode without terminating null pointer into our buffer exploit.
\end{itemize}
%===========================================


\section{Buffer Oveflow \#2}
%===========================================
% TODO: Replace this with a short description of your algorithm(s) used.
Vulnerability: Want to exploit improper for loop construction which writes 129 bytes to a 128 byte static array.\\

Exploit: We can overwrite the last byte of "previous base pointer" address which sits right above our \texttt{char* input} 
local variable in the foo stack frame. We can use this to shift our prev rbp down by 16 bytes, which prompts the program 
to return the address for \texttt{char* input} and execute arbitary code we have passed in that argument.  \\

Working notes:
\begin{itemize}
    \item Using gdb we can find address of the input variable in the foo stack frame, 0x7fffffffeb08.
    \item We then can find the address of the previous rbp in the foo stack frame, 0x7fffffffeb10.
    \item The difference of these two addresses is 0x08 (8 bytes), which makes sense, this is just the 
    memory allocated for our base pointer address. 
    \item Idea: want to overwrite the last byte of the previous rbp address with 0x00 (replaces 0x10), 
    which will shift the rbp down by 16 bytes (since we are in base 16) and cause our program to use the address 
    of our input variable as the return address and execute whatever code is stored in that memory location. 
    \item Similarly, to exploit 1, we can then just copy our shell code into the input variable (without the 
    terminatung null pointer to avoid early exit) and execute it.
    \item Note, our shellcode is only 23 bytes and so written to the bottom of our input variable (exploit). Since our 
    exploit needs to be 129 bytes long, we fill the rest with the character 'U' (easily identifiable) and then overwrite 
    the last byte (overflow) with 0x00 as expalined above.
\end{itemize}


%===========================================


%===========================================
% EXAMPLE IMAGE, TODO REPLACE WITH YOUR IMAGE
%===========================================
% \begin{figure}[h]
%     \centering
%     \includegraphics[width=0.4\textwidth]{example_graph.pdf}
%     \caption{Graph caption.}
% \end{figure}

%===========================================
% EXAMPLE PYTHON, TODO REPLACE WITH YOUR CODE:
%===========================================
% \begin{algorithm}
% \begin{lstlisting}
% import sys

% import networkx


% def write_gph(dag, idx2names, filename):
%     with open(filename, 'w') as f:
%         for edge in dag.edges():
%             f.write("{}, {}\n".format(idx2names[edge[0]], idx2names[edge[1]]))


% def compute(infile, outfile):
%     # WRITE YOUR CODE HERE
%     # FEEL FREE TO CHANGE ANYTHING ANYWHERE IN THE CODE
%     # THIS INCLUDES CHANGING THE FUNCTION NAMES, MAKING THE CODE MODULAR, BASICALLY ANYTHING
%     pass


% def main():
%     if len(sys.argv) != 3:
%         raise Exception("usage: python project1.py <infile>.csv <outfile>.gph")

%     inputfilename = sys.argv[1]
%     outputfilename = sys.argv[2]
%     compute(inputfilename, outputfilename)


% if __name__ == '__main__':
%     main()

% \end{lstlisting}
% \end{algorithm}

\end{document}