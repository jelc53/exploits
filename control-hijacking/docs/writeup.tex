\documentclass[twoside,11pt]{article}
\setlength{\parindent}{0pt}

\usepackage{cs155}
\usepackage{lipsum}
\usepackage{listings}
\usepackage{amsmath}

\input{julia_listing}


\begin{document}

% Refer to this link for project rubric: https://web.stanford.edu/class/aa228/cgi-bin/wp/project-1/
\title{Project 1: Control Hijacking}

%===========================================
% TODO: Replace "First Last" with your name.
% TODO: Replace "email@stanford.edu" with your Stanford email.
%===========================================
\name{Julian Cooper}
\email{jelc@stanford.edu}


\maketitle


\section{Buffer Overflow}
%===========================================
% TODO: Replace this with a short description of your algorithm(s) used.
Vulnerability: Want to exploit \texttt{strcpy} being called without bounds checking. \\

Exploit: We can overwrite the return address of \texttt{foo} with the address of our shellcode, then execute the shellcode to get a root shell.\\

Working notes:
\begin{itemize}
    \item Using gdb we can find address of the buffer variable, 0x7fffffffdc20.
    \item We then can find the address of the return address, 0x7fffffffdd28.
    \item The difference of these two addresses is 0x108 (264), which is the number of bytes we need to overwrite to get to the return address.
    Note, we need to add 8 bytes to this to account for the saved return address, so our exploit must be 272 bytes long.
    \item Copy shellcode without terminating null pointer into our buffer exploit.
\end{itemize}
%===========================================


\section{Off-by-One}
%===========================================
% TODO: Replace this with a short description of your algorithm(s) used.
Vulnerability: Want to exploit improper for loop construction which writes 129 bytes to a 128 byte static array.\\

Exploit: We can overwrite the last byte of "previous base pointer" address which sits right above our \texttt{char* input} 
local variable in the foo stack frame. We can use this to shift our prev rbp down by 16 bytes, which prompts the program 
to return the address for \texttt{char* input} and execute arbitary code we have passed in that argument.  \\

Working notes:
\begin{itemize}
    \item Using gdb we can find address of the input variable in the foo stack frame, 0x7fffffffeb08. 
    We then can find the address of the previous rbp in the foo stack frame, 0x7fffffffeb10.
    \item The difference of these two addresses is 0x08 (8 bytes), which makes sense, this is just the 
    memory allocated for our base pointer address. 
    \item Idea: want to overwrite the last byte of the previous rbp address with 0x00 (replaces 0x10), 
    which will shift the rbp down by 16 bytes (since we are in base 16) and cause our program to use the address 
    of our input variable as the return address and execute whatever code is stored in that memory location. 
    \item Similarly to exploit 1, we can then just copy our shell code into the input variable (without the 
    terminatung null pointer to avoid early exit) and execute it.
    \item Note, our shellcode is only 23 bytes and so written to the bottom of our input variable (exploit). Since our 
    exploit needs to be 129 bytes long, we fill the rest with the character 'U' (easily identifiable) and then overwrite 
    the last byte (overflow) with 0x00 as expalined above.
\end{itemize}
%===========================================


\section{Integer Overflow}
%===========================================
% TODO: Replace this with a short description of your algorithm(s) used.
Vulnerability: Want to exploit \texttt{count = (long)strtoul(input, \&in, 10);} which recasts an unsigned long to 
a signed long. This allows us to pass in an integer value that will be within the bounds of an unsigned long but 
overflow the signed long it is cast to and present therefore present as a negative value during \texttt{memcpy()} 
bounds check. \\

Exploit: Having passed the \texttt{memcpy()} bounds check, we can perform a similar exploit to q1 where we overwrite 
the return address of \texttt{foo} with the address of our shellcode, then execute the shellcode to get a root shell.\\

Working notes:
\begin{itemize}
    \item Using gdb we can find address of the buffer variable, 0x7ffffffe8f48. We then can find the address of the 
    return address, 0x7ffffffeed10.
    \item The difference of these two addresses is 24,000, which is the number of bytes we need to overwrite to get to 
    the return address. Note, we need to add 8 bytes to this to account for the saved return address.
    \item To solve for count string to pass at the top of our exploit, we need to meet three conditions: 
    (a) overflow the signed long, (b) be within the bounds of an unsigned long, and (c) solve for x such that 
    $24x = 24024 \:\text{mod} (2^{64})$. The first two conditions guarantee we pass the bounds check. The third condition 
    ensures our exploit is large enough to overwrite the return address.
    \item We used a solver to find x such that $24x = 24024 \: \text{mod} (2^{64})$. This gives us x = 2,305,843,009,213,693,952n + 1,001
    We then solve for n such that $2^{63} < x < 2^{64}$ and find n can be 4, 5, 6, 7 or 8. We set $n = 4$ and use the resulting  
    value and trailing comma ("9223372036854776809,") as our count string.
    \item  Copy count string followed by our shellcode (without terminating null pointer) into our buffer exploit, and 
    perform string surgery to ensure retrun address points back to begainning of our overwritten local buf variable.
    
\end{itemize}
%===========================================


\section{Off-by-One with Exit}
%===========================================
% TODO: Replace this with a short description of your algorithm(s) used.
Vulnerability: Want to exploit improper for loop construction which writes 129 bytes to a 128 byte static array. 
However, unlike for exploit 2, our foo funtion exits before returning to main. Because of this, we need to be more 
creative to exploit this vulnerability. \\

Exploit: We can overwrite the last byte of "previous base pointer" address which sits right above our \texttt{char buf} 
local variable in the bar stack frame. We use this to shift the rbp of foo up into main's stack frame somewhere in 
the middle of our \texttt{char input} local variable which we control. Our program now thinks the address just below 
our shifted foo rbp are p and a. We fill p with the address of our \texttt{\_exit(0)} call 
and a with our shellcode. This means that on line 29 of our \texttt{target.c} file, where we assign address of p to be 
the value of a, we end up executing our shell code. \\

Working notes:
\begin{itemize}
    \item Using gdb we can find address of the input variable in the main stack frame, 0x7ffffffeed40. 
    We then can find the address of the previous rbp in the foo stack frame, 0x7ffffffeed20. The difference 
    of these two addresses is 0x20 (32 bytes).
    \item Idea: want to overwrite the last byte of the previous rbp address with 0x67 (replaces 0x20), 
    which will shift the rbp down up by 71 bytes (since we are in base 16). This will cause our program to use an 
    address in the middle of our input variable from the main stack frame as the foo rbp.  
    Note, 71 = 31 bytes to input + 23 bytes for shellcode + 8 bytes for a + 8 bytes for p. 
    \item Similarly to previous exploits, we copy our shell code into the input variable (without the 
    terminatung null pointer to avoid early exit). However, in addition we now need to include addresses for a 
    (pointing to shellcode start) and p (pointing to exit call address) in our exploit. 
\end{itemize}
%===========================================


\section{Return-Oriented Programming}
%===========================================
% TODO: Replace this with a short description of your algorithm(s) used.
Vulnerability: Improper for-loop construction which writes 129 bytes to a 128 byte static array. 
However, unlike for exploit 2, our foo funtion exits before returning to main. So we need to be more 
creative to exploit this vulnerability. \\

Exploit: We can overwrite the last byte of "previous base pointer" address which sits right above our \texttt{char buf} 
local variable in the \texttt{bar()} stack frame. We can set the least significant byte of the saved RBP to
the start of \texttt{buf[]} in \texttt{foo()}. We also set the return address of \texttt{foo()} to the address of 
the "/bin/shell" text in \texttt{get-shell()}. \\

Implementing ROP, we then place the addresses of three gadgets from the source code in the \texttt{buf[]} following the shell string.
This is possible because target5.c does not check the length of our input before memcpy()'ing it into \texttt{out[]}. \\

The three gadgets are:
\begin{itemize}
    \item \texttt{MOV \%rdi, \%rax} (address: 0x4021ab). Passes \texttt{foo()}'s return value as first param to \texttt{execve()}. 
    \item \texttt{XOR \%edx, \%edx} (address: 0x40452f). By xor'ing edx with itself, this zeroes out \texttt{\%edx}.
    \item \texttt{MOV 59, \%eax} followed by a \texttt{syscall} (address: 0x4b2f24). This does \texttt{execve()}, since that's syscall number 59.
\end{itemize}

The first two gadgets set the \%rdi and \%edx register to the right values and the third calls \texttt{execve()}.
The result is that the syscall becomes: \texttt{execve("/bin/shell", 0, 0)}. \\

Open questions
\begin{itemize}
    \item Why does MOV place 59 into \%eax? Doesn't MOV place the second param into the first?
    \item Why does it keep returning and executing up in the buffer? i.e. why does it work without any EBP manipulation?
    \item Why can't we find the gadgets at above addresses in gadgets.txt? Does the find-gadgets.py program not find all gadgets?
\end{itemize}


%===========================================
%===========================================
% EXAMPLE IMAGE, TODO REPLACE WITH YOUR IMAGE
%===========================================
% \begin{figure}[h]
%     \centering
%     \includegraphics[width=0.4\textwidth]{example_graph.pdf}
%     \caption{Graph caption.}
% \end{figure}

%===========================================
% EXAMPLE PYTHON, TODO REPLACE WITH YOUR CODE:
%===========================================
% \begin{algorithm}
% \begin{lstlisting}
% import sys

% import networkx


% def write_gph(dag, idx2names, filename):
%     with open(filename, 'w') as f:
%         for edge in dag.edges():
%             f.write("{}, {}\n".format(idx2names[edge[0]], idx2names[edge[1]]))


% def compute(infile, outfile):
%     # WRITE YOUR CODE HERE
%     # FEEL FREE TO CHANGE ANYTHING ANYWHERE IN THE CODE
%     # THIS INCLUDES CHANGING THE FUNCTION NAMES, MAKING THE CODE MODULAR, BASICALLY ANYTHING
%     pass


% def main():
%     if len(sys.argv) != 3:
%         raise Exception("usage: python project1.py <infile>.csv <outfile>.gph")

%     inputfilename = sys.argv[1]
%     outputfilename = sys.argv[2]
%     compute(inputfilename, outputfilename)


% if __name__ == '__main__':
%     main()

% \end{lstlisting}
% \end{algorithm}

\end{document}
