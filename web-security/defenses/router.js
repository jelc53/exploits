import express from 'express';
import sqlite from 'sqlite';

import { asyncMiddleware } from './utils/asyncMiddleware';
import sleep from './utils/sleep';
import { generateRandomness, HMAC, KDF, checkPassword } from './utils/crypto';

const router = express.Router();
const dbPromise = sqlite.open('./db/database.sqlite')

// BRAVO defense: set req global variables
const currHmacKey = generateRandomness();
let lastTimeDate;  // concatenate with username to create CSRF, which generates HMAC

// CHARLIE defense: set req global variables
let cookieMac;

function render(req, res, next, page, title, errorMsg = false, result = null) {
  // BRAVO defense: sign csrf token (user + time) with hmac
  let user = req.session.account.username;
  lastTimeDate = new Date().toDateString();
  let currHmacSig = HMAC(currHmacKey, user + lastTimeDate);

  // FOXTROT defense
  const scriptSrcNonce = generateRandomness();
  const cspPolicy = "script-src 'strict-dynamic' 'nonce-" + scriptSrcNonce + "'";
  res.setHeader("Content-Security-Policy", cspPolicy);
  
  res.render(
    'layout/template', {
      page,
      title,
      loggedIn: req.session.loggedIn,
      account: req.session.account,
      errorMsg,
      result,
      currHmacSig, // BRAVO defense
      scriptSrcNonce, // FOXTROT defense
    }
  );
}

// CHARLIE defense: check cookie integrity
// calculates mac of the account info that we want to prevent user changing
// called whenever any of these fields are changed & user stays logged in
function calcCookieMac(req) {
  let currAcc = req.session.account;
  
  // necessary because hashing full account object leads to collisions
  let crucialAccountData = currAcc.username + String(currAcc.bitbars) + currAcc.hashedPassword;
  let hash = KDF(crucialAccountData, req.session.timestamp); // as second arg
  let mac = HMAC(currHmacKey, hash);

  return mac;
}


// CHARLIE defense: check cookie integrity
// checks if the mac of the hash of the important parts of a
// user's profile are correct and intact. logs user out if not.
function checkValidCookie(req, res, next) { 
  if (calcCookieMac(req) !== cookieMac && req.session.loggedIn) { 
    // log out user
    req.session.loggedIn = false;
    req.session.account = {};
    render(req, res, next, 'index', 'Bitbar Home', 'Logged out due to cookie tampering.');
    return false;
  }

  return true;
}


router.get('/', (req, res, next) => {
  // CHARLIE: check cookie integrity
  if (!checkValidCookie(req, res, next)) {
    return;
  };
  render(req, res, next, 'index', 'Bitbar Home');
});


router.post('/set_profile', asyncMiddleware(async (req, res, next) => {
  // CHARLIE: check cookie integrity
  if (!checkValidCookie(req, res, next)) {
    return;
  };

  req.session.account.profile = req.body.new_profile;
  const db = await dbPromise;

  // ECHO defense: changed old sql query to be parameterized
  const query = `UPDATE Users SET profile = $profile WHERE username = $user;`;
  const result = await db.run(query, {$profile: req.body.new_profile, $user: req.session.account.username});
  render(req, res, next, 'index', 'Bitbar Home');

}));


router.get('/login', (req, res, next) => {
  render(req, res, next, 'login/form', 'Login');
});


router.get('/get_login', asyncMiddleware(async (req, res, next) => {
  const db = await dbPromise;

  // ECHO defense: changed old sql query to be parameterized
  const query = `SELECT * FROM Users WHERE username == $user`;
  const result = await db.get(query, {$user: req.query.username});

  if(result) { // if this username actually exists

    // GAMMA defense part 1: add sleep call of duration between 0 and 500ms
    // to add noise and complicate attempts to use statistical methods
    // to distinguish duration between correct and incorrect pwds 
    let upperBoundRange = BigInt(501);
    let randValueInRange = BigInt(`0x${generateRandomness()}`) % upperBoundRange;

    await sleep(Number(randValueInRange));

    if(checkPassword(req.query.password, result)) { // if password is valid
      // GAMMA defense part 2: remove sleep() call
      // await sleep(2000);

      req.session.loggedIn = true;
      req.session.account = result;

      // CHARLIE defense: set cookies
      let timeInMs = Date.now();
      timeInMs = String(timeInMs);
      req.session.timestamp = timeInMs;

      cookieMac = calcCookieMac(req);
      req.session.mac = cookieMac;
      

      render(req, res, next, 'login/success', 'Bitbar Home');
      return;
    }

  }
  render(req, res, next, 'login/form', 'Login', 'This username and password combination does not exist!');
}));


router.get('/register', (req, res, next) => {
  render(req, res, next, 'register/form', 'Register');
});


router.post('/post_register', asyncMiddleware(async (req, res, next) => {
  const db = await dbPromise;

  // ECHO defense: changed old sql query to be parameterized
  let query = `SELECT * FROM Users WHERE username == $user`;
  let result = await db.run(query, {$user: req.body.username});

  if(result) { // query returns results
    if(result.username === req.body.username) { // if username exists
      render(req, res, next, 'register/form', 'Register', 'This username already exists!');
      return;
    }
  }
  const salt = generateRandomness();
  const hashedPassword = KDF(req.body.password, salt);
  query = `INSERT INTO Users(username, hashedPassword, salt, profile, bitbars) VALUES(?, ?, ?, ?, ?)`;
  await db.run(query, [req.body.username, hashedPassword, salt, '', 100]);
  req.session.loggedIn = true;
  req.session.account = {
    username: req.body.username,
    hashedPassword,
    salt,
    profile: '',
    bitbars: 100,
  };

  // CHARLIE: update cookieMac
  cookieMac = calcCookieMac(req);

  render(req, res, next,'register/success', 'Bitbar Home');
}));


router.get('/close', asyncMiddleware(async (req, res, next) => {
  // CHARLIE: check cookie integrity
  if (!checkValidCookie(req, res, next)) {
    return;
  };

  if(req.session.loggedIn == false) {
    render(req, res, next, 'login/form', 'Login', 'You must be logged in to use this feature!');
    return;
  };
  const db = await dbPromise;

  // ECHO defense: changed sql old query to be parameterized
  const query = `DELETE FROM Users WHERE username == $user`;
  await db.run(query, {$user: req.session.account.username});
  
  req.session.loggedIn = false;
  req.session.account = {};
  render(req, res, next, 'index', 'Bitbar Home', 'Deleted account successfully!');
}));


router.get('/logout', (req, res, next) => {
  // CHARLIE: check cookie integrity
  if (!checkValidCookie(req, res, next)) {
    return;
  };

  req.session.loggedIn = false;
  req.session.account = {};
  render(req, res, next, 'index', 'Bitbar Home', 'Logged out successfully!');
});

// ALPHA defense: only accept alphanumeric usernames
function isValidUsername(username) {
  let alphaNumericRegex = /^[a-z0-9]+$/i;
  return alphaNumericRegex.test(username);
};

router.get('/profile', asyncMiddleware(async (req, res, next) => {
  if(req.session.loggedIn == false) {
    render(req, res, next, 'login/form', 'Login', 'You must be logged in to use this feature!');
    return;
  };

  // CHARLIE: check cookie integrity
  if (!checkValidCookie(req, res, next)) {
    return;
  };

  // ALPHA defense: reroute user to view their own profile
  // if they try to view an invalid username
  if(!isValidUsername(req.query.username)) {
    render(req, res, next, 'profile/view', 'View Profile', `That is not a valid username! Valid usernames may only contain alphanumeric characters.`, req.session.account);
    return;
  }

  if(req.query.username != null) {
    const db = await dbPromise;

    // ECHO defense (1/2): changed old sql query to be parameterized  
    // const query = `SELECT * FROM Users WHERE username == "${req.query.username}";`;
    const query = `SELECT * FROM Users WHERE username == $user`;

    let result;
    try {
      // ECHO defense (2/2): changed old sql query to be parameterized  
      // result = await db.get(query);
      result = await db.get(query, {$user: req.query.username});
    } catch(err) {
      result = false;
    }
    if(result) { // if user exists
      render(req, res, next, 'profile/view', 'View Profile', false, result);
    }
    else { // user does not exist
      render(req, res, next, 'profile/view', 'View Profile', `${req.query.username} does not exist!`, req.session.account);
    }
  } else { // visitor did not make query, show them their own profile
    render(req, res, next, 'profile/view', 'View Profile', false, req.session.account);
  }
}));


router.get('/transfer', (req, res, next) => {
  // CHARLIE: check cookie integrity
  if (!checkValidCookie(req, res, next)) {
    return;
  };

  if(req.session.loggedIn == false) {
    render(req, res, next, 'login/form', 'Login', 'You must be logged in to use this feature!');
    return;
  };

  render(req, res, next, 'transfer/form', 'Transfer Bitbars', false, {receiver:null, amount:null});
});


router.post('/post_transfer', asyncMiddleware(async(req, res, next) => {
  // CHARLIE defense
  if (!checkValidCookie(req, res, next)) {
    return;
  };

  if(req.session.loggedIn == false) {
    render(req, res, next, 'login/form', 'Login', 'You must be logged in to use this feature!');
    return;
  };

  // CHARLIE: check cookie integrity
  if (!checkValidCookie(req, res, next)) {
    return;
  };

  if(req.body.destination_username === req.session.account.username) {
    render(req, res, next, 'transfer/form', 'Transfer Bitbars', 'You cannot send money to yourself!', {receiver:null, amount:null});
    return;
  }

  // BRAVO defense: check csrf token & hmac sig
  let serverHmacSig = HMAC(currHmacKey, req.session.account.username + lastTimeDate);
  
  if(req.body.hmacSig !== serverHmacSig) { // CSRF token tampering detected...
    req.session.loggedIn = false;
    req.session.account = {};
    render(req, res, next, 'index', 'Bitbar Home', 'Logged out due to incorrect csrf token.');
    return; 
  }

  const db = await dbPromise;

  // ECHO defense: changed old sql query to be parameterized
  let query = `SELECT * FROM Users WHERE username == $user`;
  const receiver = await db.get(query, {$user: req.body.destination_username});

  if(receiver) { // if user exists
    const amount = parseInt(req.body.quantity);
    if(Number.isNaN(amount) || amount > req.session.account.bitbars || amount < 1) {
      render(req, res, next, 'transfer/form', 'Transfer Bitbars', 'Invalid transfer amount!', {receiver:null, amount:null});
      return;
    }

    req.session.account.bitbars -= amount;
    // ECHO defense: changed old sql query to be parameterized
    query = `UPDATE Users SET bitbars = $bitbars WHERE username == $user;`;
    await db.exec(query, {$bitbars: req.session.account.bitbars, $user: req.session.account.username});
    
    const receiverNewBal = receiver.bitbars + amount;
    // ECHO defense: changed old sql query to be parameterized
    query = `UPDATE Users SET bitbars = $balance WHERE username == $user;`;
    await db.exec(query, {$balance: receiverNewBal, $user: req.session.account.username});

    // CHARLIE defense: update cookieMac
    cookieMac = calcCookieMac(req);

    render(req, res, next, 'transfer/success', 'Transfer Complete', false, {receiver, amount});
  } else { // user does not exist
    let q = req.body.destination_username;
    if (q == null) q = '';

    let oldQ;
    while (q !== oldQ) {
      oldQ = q;
      q = q.replace(/script|SCRIPT|img|IMG/g, '');
    }
    render(req, res, next, 'transfer/form', 'Transfer Bitbars', `User ${q} does not exist!`, {receiver:null, amount:null});
  }
}));


router.get('/steal_cookie', (req, res, next) => {
  let stolenCookie = req.query.cookie;
  console.log('\n\n' + stolenCookie + '\n\n');
  render(req, res, next, 'theft/view_stolen_cookie', 'Cookie Stolen!', false, stolenCookie);
});

router.get('/steal_password', (req, res, next) => {
  let password = req.query.password;
  let timeElapsed = req.query.timeElapsed;
  console.log(`\n\nPassword: ${req.query.password}, time elapsed: ${req.query.timeElapsed}\n\n`);
  res.end();
});

module.exports = router;